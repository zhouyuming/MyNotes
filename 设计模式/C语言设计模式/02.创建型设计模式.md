# 创建型设计模式

## 工厂

### 工厂的分类

#### 简单工厂

我给你一个类型，你还我一个接口

- 基本概念

也叫静态工厂方法，实现一个函数，通过参数的不同得到一个统一的接口对象

对于C语言来说，也就是得到一个或者一组（数据结构封装）接口函数

- 应用场景

实际在我们的代码中，大量的用到了简单工厂这个设计模式，比如我们实现一个简单的状态机，维护了一张函数指针表，在处理业务时，根据当前的状态，以及消息的类型从表中得到对应的处理函数的指针，实现这样一个函数就是简单工厂的典型应用

在业务实现过程中，把做什么的具体实现抽象成为一个接口函数（也就是这里的函数指针），通过简单工厂获取的这个接口函数。当接口函数增加或者删除时，我们业务实现的代码不需要做改变就能够完成新需求的变更，这也就是我们通常讲到的开闭原则

我们的C语言代码经常用到一种方法叫做表驱动模式，这种设计方法的背后思想与我们常见的设计模式基本一致

```C
XxxFunc_S g_XxxFuncTable[]={
  {"status_x_msg_a", STATUS_X, MSG_A, funcXA},
  {"status_x_msg_b", STATUS_X, MSG_B, funcXB},
  {"status_x_msg_c", STATUS_X, MSG_C, funcXC},
  {"status_y_msg_a", STATUS_Y, MSG_A, funcYA},
  {"status_y_msg_b", STATUS_Y, MSG_B, funcYB},
  {"status_y_msg_c", STATUS_Y, MSG_C, funcYC},
  {"status_z_msg_a", STATUS_Z, MSG_A, funcZA},
  {"status_z_msg_b", STATUS_Z, MSG_B, funcZB},
  {"status_z_msg_c", STATUS_Z, MSG_C, funcZC}
};

XyzFunc* getXxxFunc(StatusType status, MsgType msg)
{
  int funcSize = sizeof(g_XxxFuncTable) / sizeof(XxxFunc_S);
  for(int i = 0; i < funcSize; i++) {
    if(status ==g_XxxFuncTable[i].status && msg == g_XxxFuncTable[i].msg) {
      return g_XxxFuncTable[i].func;
    }
  }
  return NULL;
}
```

#### 工厂方法

启动退出排排队，一个接着一个来

- 两个核心思想

统一的创建对象的对象（接口方法）

统一的被创建出的对象（接口方法）

- 统一的创建对象的方法-工厂方法模式的思想

工厂方法由于每个对象通过不同的函数来构建，所以解决不同对象构建过程、参数差异化的问题，这个通过简单工厂很难完成。

C++/Java为了解决创建对象不统一的情况，经常创建一个接口类，定了一些类属性的接口(name，type)或者initial/destroy等方法，而同样继承了该接口的派生类行为本身没有太多的关联。

#### 抽象工厂

模块解耦找工厂，接口抽象注依赖



用一个表来保存一些关键信息与接口函数的对应关系，通过关键信息来找到接口函数，如果能够通过数组下标直接获得或者通过一定的线性计算得到是最理想的情况，再或者是数组元素不多时通过遍历比较得到

通过一个get函数来隔离使用者与定义的表之间的耦合，其核心思想与面向对象里的简单工厂方法完全一致


### 简单工厂 VS 工厂方法

#### 简单工厂

- 使用场景

业务代码使用一个抽象接口时，在代码中通过简单工厂方法要获取一个抽象接口对象（一个/组函数指针）进行调用

- 实现方式

简单工厂方法实现了一个函数，该函数可以传入一个或多个参数，基于参数类型的不同，获得同样接口类型的不同接口实例（一个/组函数指针）

#### 工厂方法

- 使用场景

工厂模式在组件的架构层面有很多应用场景，在组件内部模块的构造、初始化、销毁、析构时，可以通过工厂方法的思想进行管理

- 实现方式

跳出模式定义的束缚，通过统一的构造方法，对于一系列模块、对象进行统一的创建过程。对于创建的对象本身是不是统一不必在意，关注要解决的问题

### 抽象工厂模式

- 模式思想

抽象工厂可以管理多个不同的对象

抽象工厂接口统一，使用者可以获取不同的抽象工厂实例

接口依赖

依赖注入

### 单例模式-Singleton

- 饿汉模式

- 懒汉模式

### 建造者-Builder

- 基本概念

亦称创建者模式、生成器模式等；该模式是将一个复杂的对象分解为许多简单的对象，然后逐步构建出想要的产品，产品的最终形态都是一致的，但是具体组成的每个对象可能是不相同的；

- 优点

将复杂对象的构建与表示分离；只需要选择具体的组成对象即可创建出复杂的对象，无需知道建造细节。

### 原型-Prototype
